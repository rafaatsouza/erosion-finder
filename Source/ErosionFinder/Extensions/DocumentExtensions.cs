using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace ErosionFinder.Extensions
{
    internal static class DocumentExtension
    {
        private const string AllowedLanguage = "C#";

        private static List<Regex> excludedNamesRegex { get; }
            = new List<Regex>()
            {
                new Regex(@"(.*(AssemblyInfo\.)cs$)"),
                new Regex(@"(.*(\.g\.)cs$)"),
                new Regex(@"(.*(\.designer\.)cs$)"),
                new Regex(@"(.*(\.AssemblyInfo\.)cs$)"),
                new Regex(@"(.*(\.generated\.)cs$)"),
                new Regex(@"(.*(\.g\.)cs$)"),
                new Regex(@"(.*(\.g\.i\.)cs$)"),
                new Regex(@"(.*(\.AssemblyAttributes\.)cs$)")
            };

        private static List<string> excludedFolders { get; }
            = new List<string>() { "obj", "debug" };

        public static async Task<bool> IsInExcludedListAsync(
            this Document document, CancellationToken cancellationToken)
        {
            if (!document.SupportsSyntaxTree)
                return true;

            if (cancellationToken.IsCancellationRequested)
                return true;

            var syntaxRoot = await document
                .GetSyntaxRootAsync(cancellationToken);

            var isInExcludedFolder = document.Folders
                .Any(f => excludedFolders.Any(ef => ef.Equals(f)));

            var hasExcludedName = excludedNamesRegex
                .Any(r => r.IsMatch(document.Name));

            return isInExcludedFolder || hasExcludedName
                || !string.Equals(syntaxRoot.Language, AllowedLanguage)
                || CheckIfNodeContainsAutoGeneratedCode(syntaxRoot);
        }

        private static bool CheckIfNodeContainsAutoGeneratedCode(SyntaxNode node)
        {
            if (node == null)
                return true;

            var trivia = node.DescendantTokens()
                .SelectMany(t => t.LeadingTrivia)
                .Where(t => t != null && t.IsKind(SyntaxKind.SingleLineCommentTrivia));

            if (!trivia.Any())
                return false;

            return trivia.Any(t => t.ToString().StartsWith("// <auto-generated>"));
        }
    }
}